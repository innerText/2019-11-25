<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    /* 
    调用Generator 函数后，该函数并不执行，返回的也不是函数运行结果
    而是一个**指向内部状态**的指针对象，也就是上一章介绍的遍历器对象(Iterator Object)

    总结一下，调用Generator  函数，返回一个遍历器对象，
    代表Generator函数的内部指针。一开始函数是不会执行的，应为它是一个状态对象

    如何让这个Generator函数执行呢？

    每次调用遍历器对象的next方法，就会返回一个有这value和done两个属性对象。
    {value:xx,done:false}

    value属性表示当前的内部状态的值，是yield或者return表达式后面那个表达式的值:

    done属性是一个布尔值，表示遍历结束。false代表没结束，true代表结束了
    
    
    
    
    
     */


    //  function* fn(){
    //      console.log(1);
    //      yield 'halou';
    //      console.log(2);
    //      return 3;
         
         
    //  }
    //  let f =fn()
    //  console.log(f.next());
    //  console.log(f.next());
    //  console.log(f.next());

    //  function* gen(){
    //      yield 2+1
    //  }
    //  console.log(gen().next().value);

    // function* fn(){//同步编程函数，这个函数就算有异步也算同步
    // console.log(1);
    // let a=yield;//异步的数据已经到手；
    // console.log(a);
    // console.log(2);
    // }


    // function* foo(x){
    //     var y = 2*(yield (x + 1));
    //     console.log(y);
        
    //     var z = yield (y/3);
    //     return (x + y + z);

    // } 
    // var a = foo(5);//遍历对象

    //  let b=a.next();
    // //  console.log(b.value);
    // a.next(12)
    
    function* fnn(){
        yield '1';
        yield '2';

    }
    function* ff(){
        yield* fnn();
        yield '3';
    }
    for (let i of ff()){
        console.log(i);
        
    }
    let a= (function* (){
        yield '1'
    })()
    console.log(a.next1);
    

     
    
    
    
    
    
    </script>
</body>
</html>